package parsesql

import (
	"fmt"
	"io/ioutil"
	"path/filepath"
	"sync"

	"github.com/fioncat/go-gendb/build"
	"github.com/fioncat/go-gendb/compile/scan/scango"
	"github.com/fioncat/go-gendb/compile/scan/scansql"
	"github.com/fioncat/go-gendb/compile/token"
	"github.com/fioncat/go-gendb/generate"
	"github.com/fioncat/go-gendb/generate/coder"
	"github.com/fioncat/go-gendb/misc/errors"
	"github.com/fioncat/go-gendb/misc/iter"
	"github.com/fioncat/go-gendb/misc/set"
	"github.com/fioncat/go-gendb/misc/workerpool"
)

// OperResult represents the result of the DB operation
// by parsing the Go file.
// OperResult is produced on the tagged Go interface.
// They have a one-to-one correspondence.
// DB operations include a series of methods, these methods
// will be associated with the sql statement in the sql file.
// The data stored in this structure has all been correlated
// and parsed, and can be directly used for code generation.
type OperResult struct {
	// Name corresponds to the name of the go interface.
	Name string `json:"name"`

	// All methods of this OperResult.
	Methods []Method `json:"methods"`

	key string
}

func (r *OperResult) Type() string { return "db-oper" }
func (r *OperResult) Key() string  { return r.key }

// Method represents a specific SQL statement call. When
// the code is generated, a specific function is generated
// for it. Method contains a lot of data and elements, and
// its fields include sql statement information and function
// information, which is suitable for any scenario where to
// generate sql statement call function.
//
// Note that the definition of the method is standardized and
// must meet:
//      <name>(<params>) (<ret>, error)
//
// There are also constraints on <ret>. If the sql statement
// is an execution statement, <ret> must be "int64" (used to
// return "affect" and "lastid") or "sql.Result"; if the sql
// statement is a query statement, then <ret> has no additional
// restrictions, but it must be able to receive the query results
// of the sql statement, otherwise the generated code will have
// compilation errors. See the online documentation for specific
// rules.
type Method struct {
	// Type represents the method type, and there are the
	// following types:
	//    Exec_Affect, Exec_Result, Exec_lastId
	//    Query_Many, Query_One
	Type string `json:"type"`

	// Name corresponds to the method name in the
	// Go interface.
	Name string `json:"name"`

	// IsExec represents whether the method is a execution
	// SQL statement, if it is false, it means that this is
	// a query statement.
	IsExec bool `json:"is_exec"`

	// SQL stores the specific data of the sql statement.
	SQL SQL `json:"sql"`

	// Origin stores the original definition of this
	// method in Go code.
	Origin string `json:"origin"`

	// RetType stores the return value type of the method.
	// NOTE: This field is only used in query statements.
	RetType string `json:"ret_type"`

	// RetSlice indicates whether the method returns a slice,
	// if true, it means that the query will return multiple values.
	// NOTE: This field is only used in query statements.
	RetSlice bool `json:"ret_slice"`

	// RetPointer indicates whether the method returns a pointer.
	// NOTE: This field is only used in query statements.
	RetPointer bool `json:"ret_pointer"`

	// RetStruct represents the structure that this method needs
	// to generate. Only applicable to the "auto-ret" configuration.
	RetStruct *coder.Struct `json:"ret_struct"`

	// Imports represents the external imports used by
	// this method.
	Imports []coder.Import `json:"imports"`

	// QueryFields represents the return value of the method,
	// which is generated by parsing SQL statements.
	// NOTE: This field is only used in query statements.
	QueryFields []QueryField `json:"query_fields"`

	QueryTables []QueryTable `json:"query_tables"`

	// use for check duplcate imports.
	importNames *set.Set
}

// sql types
const (
	sqlExecAffect = "Exec_Affect"
	sqlExecLastid = "Exec_lastId"
	sqlExecResult = "Exec_Result"
	sqlQueryMany  = "Query_Many"
	sqlQueryOne   = "Query_One"
)

// IsAffect returns whether method's type is execAffect.
func (m *Method) IsAffect() bool {
	return m.Type == sqlExecAffect
}

// IsLastId returns whether method's type is execLastid.
func (m *Method) IsLastId() bool {
	return m.Type == sqlExecLastid
}

// IsResult returns whether method's type is execResult.
func (m *Method) IsResult() bool {
	return m.Type == sqlExecResult
}

// IsQueryOne returns whether method's type is queryOne.
func (m *Method) IsQueryOne() bool {
	return m.Type == sqlQueryOne
}

// IsQueryMany returns whether method's type is queryMany.
func (m *Method) IsQueryMany() bool {
	return m.Type == sqlQueryMany
}

// QueryField represents the SELECT field of the sql
// query statement.
// The usual format is: "[table.]field [[AS] alias]"
type QueryField struct {
	Table string `json:"table"`
	Field string `json:"field"`
	Alias string `json:"alias"`
}

// QueryTable represents the query table of SQL query
// statements. Can come from: FROM clause, JOIN clause.
// If it comes from FROM, the format is "FROM table [[AS] alias]";
// if it comes from JOIN, the format is "JOIN table [[AS] alias]"
type QueryTable struct {
	Name  string `json:"name"`
	Alias string `json:"alias"`
}

// SQL represents a sql statement. In addition to the
// basic sql syntax, it may also contain two placeholders:
// "${name}" and "#{name}". The former will be saved in
// Prepares and replaced with "?" in the sql statement;
// the latter will be saved in Replaces and replaced with
// "%v" in the sql statement.
type SQL struct {
	Contant  string   `json:"contant"`
	Prepares []string `json:"prepares"`
	Replaces []string `json:"replaces"`
}

// sqlMap is used to index sql statement by name.
type sqlMap map[string]scansql.Statement

// Parser is used to parse the scan results of sql type go files.
// The prefix tags for these files are: "// +gendb sql"
type Parser struct {
}

// Do performs analysis.
func (*Parser) Do(sr *scango.Result) ([]generate.Result, error) {
	dir := filepath.Dir(sr.Path)
	var results []generate.Result
	for _, inter := range sr.Interfaces {
		var oper OperResult
		err := _interface(&oper, sr, &inter, dir)
		if err != nil {
			return nil, err
		}
		oper.key = fmt.Sprintf("oper.%s", inter.Name)
		results = append(results, &oper)
	}

	return results, nil
}

// parse interface into OperResult
func _interface(or *OperResult, sr *scango.Result, inter *scango.Interface, dir string) error {
	or.Name = inter.Name

	// read sql file's path from tags.
	sqlPaths := make([]string, 0, 1)
	for _, tag := range inter.Flag.Tags {
		if len(tag.Args) == 0 {
			return errors.NewComp(sr.Path, tag.Line,
				"the tag's arg is empty, except paths")
		}
		sqlPaths = append(sqlPaths, tag.Args...)
	}

	if len(sqlPaths) == 0 {
		return errors.NewComp(sr.Path, inter.Line,
			"the interface has not sql file")
	}

	// Scan sql files
	sqlM := make(sqlMap)
	wp := workerpool.New(len(sqlPaths),
		build.N_WORKERS, scanSqlWorker(sqlM, dir))
	wp.Start()
	for _, path := range sqlPaths {
		path := path
		wp.Do(path)
	}
	if err := wp.Wait(); err != nil {
		return errors.Trace("read sql file", err)
	}

	// Parse methods
	wp = workerpool.New(len(inter.Methods),
		build.N_WORKERS, parseMethodWorker(or, sr, sqlM))
	wp.Start()
	for _, m := range inter.Methods {
		m := m
		wp.Do(&m)
	}

	if err := wp.Wait(); err != nil {
		return err
	}

	return nil
}

var mu sync.Mutex

func scanSqlWorker(sqlM sqlMap, dir string) workerpool.WorkFunc {
	return func(task interface{}) error {
		path := (task).(string)
		path = filepath.Join(dir, path)

		data, err := ioutil.ReadFile(path)
		if err != nil {
			return err
		}

		sqlResult, err := scansql.Do(path, string(data))
		if err != nil {
			return err
		}

		for _, sql := range sqlResult.Statements {
			if _, ok := sqlM[sql.Name]; ok {
				return errors.NewComp(path, sql.LineNum,
					`sql "%s" is duplcate`, sql.Name)
			}
			mu.Lock()
			sqlM[sql.Name] = sql
			mu.Unlock()
		}

		return nil
	}
}

func parseMethodWorker(or *OperResult, sr *scango.Result, sqlM sqlMap) workerpool.WorkFunc {
	return func(task interface{}) error {
		method := task.(*scango.Method)
		mr, err := _method(method, sr, sqlM)
		if err != nil {
			return err
		}
		mu.Lock()
		or.Methods = append(or.Methods, *mr)
		mu.Unlock()
		return nil
	}
}

// parse go interfaces' method into Method struct.
func _method(method *scango.Method, sr *scango.Result, sm sqlMap) (*Method, error) {
	iter := iter.New(method.Tokens)
	mr := new(Method)
	err := _goMethod(iter, sr.Path, method.Line, mr)
	if err != nil {
		return nil, err
	}
	mr.Origin = method.Origin

	for _, importName := range mr.importNames.Slice() {
		found := false
		for _, imp := range sr.Imports {
			if imp.Name == importName {
				mr.Imports = append(mr.Imports, coder.Import{
					Name: imp.Name,
					Path: imp.Path,
				})
				found = true
				break
			}
		}
		if !found {
			return nil, errors.NewComp(sr.Path, method.Line,
				`can not find import name "%s"`, importName)
		}
	}

	sql, ok := sm[mr.Name]
	if !ok {
		return nil, errors.NewComp(sr.Path, method.Line,
			`can not find sql for method "%s"`, mr.Name)
	}

	err = _sql(sr.Path, sql, mr, method)
	if err != nil {
		return nil, err
	}

	return mr, nil
}

// parse go method tokens.
// The format is: "<name>(<params>) (<ret-type>, error)"
func _goMethod(iter *iter.Iter, path string, lineNum int, m *Method) error {
	var tk token.Token

	ef := errors.NewParseFactory(path, lineNum)

	// 1st: method name
	idx := iter.NextP(&tk)
	if idx < 0 {
		return ef.EarlyEnd("INDENT")
	}
	if !tk.IsIndent() {
		return ef.MismatchS(idx, "INDENT", tk)
	}
	m.Name = tk.Get()

	if m.Name == "" {
		return ef.Empty(idx, "method_name")
	}

	// 2nd: params
	idx = iter.NextP(&tk)
	if idx < 0 {
		return ef.EarlyEnd(token.LPAREN.String())
	}
	if !tk.Match(token.LPAREN) {
		return ef.Mismatch(
			idx, token.LPAREN, tk)
	}
	m.importNames = set.New()
	for {
		idx = iter.Pick(&tk)
		if idx < 0 {
			return ef.EarlyEnd(token.RPAREN.Get())
		}
		if token.RPAREN.Match(tk) {
			iter.Next(&tk)
			break
		}

		if token.PERIOD.Match(tk) {
			// The previous is import name
			idx = iter.Previous(&tk)
			if idx < 0 {
				// theoretically impossible to trigger
				return ef.EarlyEnd("INDENT")
			}

			if !tk.IsIndent() {
				return ef.MismatchS(idx, "INDENT", tk)
			}
			m.importNames.Append(tk.Get())
		}
		iter.Next(&tk)
	}

	// 3rd: returns
	idx = iter.NextP(&tk)
	if idx < 0 {
		return ef.EarlyEnd(token.LPAREN.Get())
	}
	if !token.LPAREN.Match(tk) {
		return ef.Mismatch(idx, token.LPAREN, tk)
	}
	// the first return must be target
	idx = iter.Pick(&tk)
	if idx < 0 {
		return ef.EarlyEnd("INDENT or KEY")
	}
	if !tk.IsIndent() {
		switch {
		case token.BRACKS.Match(tk):
			m.RetSlice = true
			iter.Next(nil)
			idx = iter.Pick(&tk)
			if idx < 0 {
				return ef.EarlyEnd("INDENT or KEY")
			}
			if token.MUL.Match(tk) {
				m.RetPointer = true
				iter.Next(nil)
			}

		case token.MUL.Match(tk):
			m.RetPointer = true
			iter.Next(nil)

		default:
			return ef.MismatchS(idx,
				"* or []", tk)
		}
	}
	idx = iter.NextP(&tk)
	if idx < 0 {
		return ef.EarlyEnd("INDENT")
	}
	if !tk.IsIndent() {
		return ef.MismatchS(idx, "INDENT", tk)
	}
	if tk.Get() == "" {
		return ef.Empty(idx, "return type")
	}

	var nextTk token.Token
	iter.Pick(&nextTk)
	if token.PERIOD.Match(nextTk) {
		m.importNames.Append(tk.Get())
		m.RetType = tk.Get() + token.PERIOD.Get()
		iter.Next(nil)
		idx = iter.NextP(&tk)
		if idx < 0 {
			return ef.EarlyEnd("INDENT")
		}
		if !tk.IsIndent() {
			return ef.MismatchS(idx, "INDENT", tk)
		}
		if tk.Get() == "" {
			return ef.Empty(idx, "return type")
		}
	}
	m.RetType += tk.Get()

	idx = iter.NextP(&tk)
	if idx < 0 {
		return ef.EarlyEnd(token.COMMA.Get())
	}
	if !token.COMMA.Match(tk) {
		return ef.Mismatch(idx, token.COMMA, tk)
	}

	idx = iter.NextP(&tk)
	if idx < 0 {
		return ef.EarlyEnd(token.GO_ERROR.Get())
	}
	if !token.GO_ERROR.Match(tk) {
		return ef.Mismatch(idx, token.GO_ERROR, tk)
	}

	idx = iter.NextP(&tk)
	if idx < 0 {
		return ef.EarlyEnd(token.RPAREN.Get())
	}
	if !token.RPAREN.Match(tk) {
		return ef.Mismatch(idx, token.RPAREN, tk)
	}

	return nil
}
