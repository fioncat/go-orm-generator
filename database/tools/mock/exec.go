package mock

import (
	"fmt"
	"io/ioutil"
	"strconv"
	"strings"
	"sync/atomic"
	"time"

	"github.com/fioncat/go-gendb/build"
	"github.com/fioncat/go-gendb/database/conn"
	"github.com/fioncat/go-gendb/database/rdb"
	"github.com/fioncat/go-gendb/misc/wpool"
)

const sqlFileHeader = `-- ------------------------------------------------------------
-- This file is auto generated by go-gendb mock tools.
-- go-gendb version: %s
-- Source file: %s
-- Create date: %s
-- Epoch: %d
-- Num of sql: %d
-- Please create the database first before executing this file.
-- ------------------------------------------------------------

`

func body(epochs [][]string) ([]string, int64) {
	var nSql int64
	bodys := make([]string, 0, len(epochs))
	for idx, sqls := range epochs {
		bodys = append(bodys, "-- epoch: "+strconv.Itoa(idx+1))
		for _, sql := range sqls {
			nSql += 1
			bodys = append(bodys, sql+";")
		}
		bodys = append(bodys, "")
	}
	return bodys, nSql
}

func writeFile(arg *Arg, epochs [][]string, connKey string) error {
	bodys, nSql := body(epochs)
	dateStr := time.Now().Format(build.DATEFMT)
	header := fmt.Sprintf(sqlFileHeader, build.VERSION,
		arg.Path, dateStr, len(epochs), nSql)

	var dbName string
	cfg, _ := conn.Get(connKey)
	if cfg != nil {
		dbName = cfg.Database
	}

	content := header
	if dbName != "" {
		content += "USE " + dbName + "\n\n"
	}

	content += strings.Join(bodys, "\n")
	data := []byte(content)

	fmt.Println("writing file...")
	err := ioutil.WriteFile(arg.File, data, 0644)
	if err != nil {
		return err
	}

	return nil
}

func exec(mute bool, epochs [][]string, nWorker int) error {
	wp := wpool.New().Worker(nWorker).Total(len(epochs))
	wp.Action(func(idx int) error {
		sqls := epochs[idx]
		err := rdb.Get().RunBatch(sqls)
		if err != nil {
			return err
		}
		atomic.AddInt32(&total, 1)
		return nil
	})

	var reporter *reporter
	if !mute {
		initTotal(len(epochs))
		reporter = newReporter("executing")
		go reporter.work()
	}

	for idx := range epochs {
		wp.SubmitArgs(idx)
	}

	err := wp.Wait()
	if !mute {
		reporter.stop(err)
	}

	return err
}
