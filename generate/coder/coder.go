package coder

import (
	"fmt"
	"io/ioutil"
	"sort"
	"strconv"
	"strings"
	"unicode"

	"github.com/fioncat/go-gendb/build"
	"github.com/fioncat/go-gendb/misc/set"
)

// Coder is used to generate code line by line. It
// includes the basic structure of Go code.
type Coder struct {
	// Source is the original file path, uses to
	// generate comments.
	Source string
	// Pkg is the package definition.
	Pkg string
	// Imports is all import definition
	Imports []Import
	// Vars is all global variable(s) definition
	Vars []Var
	// Consts is all global const(s) definition
	Consts []Var
	// Structs is all struct(s) definition
	Structs []Struct
	// Contents is code body
	Contents []string

	importsSet *set.Set
}

// Var represents the global variable definition.
type Var struct {
	// Name of the variable
	Name string
	// Value of the variable
	Value string
}

// Import represents the import definition
type Import struct {
	// Name can be empty
	Name string `json:"name"`
	// Path of the import.
	Path string `json:"path"`
}

// Struct represents the struct definition
type Struct struct {
	// Comment of the struct
	Comment string `json:"comment"`
	// Name of the struct
	Name string `json:"name"`
	// All fields
	Fields []Field `json:"fields"`

	fm map[string]struct{}
}

// Merge merges the two structures and traverses the "os"
// field. If the field name does not exist in the current
// structure, insert the field into the current structure.
func (s *Struct) Merge(os *Struct) {
	if s.Name != os.Name {
		return
	}
	if s.fm == nil {
		s.fm = make(map[string]struct{})
		for _, f := range s.Fields {
			s.fm[f.Name] = struct{}{}
		}
	}

	for _, f := range os.Fields {
		_, ok := s.fm[f.Name]
		if ok {
			continue
		}
		s.Fields = append(s.Fields, f)
	}
}

// Field represents the field in the structure.
type Field struct {
	Comment string     `json:"comment"`
	Name    string     `json:"name"`
	Type    string     `json:"type"`
	Tags    []FieldTag `json:"tags"`
}

// AddTag add a tag for the field.
func (f *Field) AddTag(name, val string) {
	tag := FieldTag{
		Name:  name,
		Value: val,
	}
	f.Tags = append(f.Tags, tag)
}

// FieldTag represents the tag of the field in the structure.
type FieldTag struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

var codePrefix = []string{
	"// Code generated by go-gendb. DO NOT EDIT.",
	"// go-gendb version: %s",
	"// source: %s",
}

func newVar(name string, vs ...interface{}) Var {
	val := comb(vs...)
	var v Var
	v.Name = name
	v.Value = val
	return v
}

// AddStruct adds a structure to the code.
func (c *Coder) AddStruct(s Struct) {
	sort.Slice(s.Fields, func(i, j int) bool {
		return s.Fields[i].Name < s.Fields[j].Name
	})
	c.Structs = append(c.Structs, s)
	for _, f := range s.Fields {
		if f.Type == "time.Time" {
			c.AddImport("time", "time")
		}
	}
}

// AddImport adds an import statement to the code.
func (c *Coder) AddImport(name, path string) {
	if c.importsSet == nil {
		c.importsSet = set.New()
	}
	if c.importsSet.Contains(name) {
		return
	}
	c.importsSet.Append(name)

	var imp Import
	imp.Name = name
	imp.Path = path

	c.Imports = append(c.Imports, imp)
}

// AddVar adds a global variable to the code.
func (c *Coder) AddVar(name string, vs ...interface{}) {
	c.Vars = append(c.Vars, newVar(name, vs...))
}

// AddConst adds a global constant to the code.
func (c *Coder) AddConst(name string, vs ...interface{}) {
	c.Consts = append(c.Consts, newVar(name, vs...))
}

// P adds a line to the code body.
func (c *Coder) P(n int, vs ...interface{}) {
	code := comb(vs...)
	prefix := strings.Repeat("\t", n)
	code = prefix + code
	c.Contents = append(c.Contents, code)
}

// Empty appends an empty line to the code body.
func (c *Coder) Empty() {
	c.Contents = append(c.Contents, "")
}

// Write writes the code to a file on disk
func (c *Coder) Write(path string) error {
	lines := make([]string, 0, 5+len(c.Contents))
	lines = append(lines, c.genHeader()...)
	lines = append(lines, c.genPkg())
	lines = append(lines, "")
	if len(c.Imports) > 0 {
		lines = append(lines, c.genImport()...)
		lines = append(lines, "")
	}
	if len(c.Vars) > 0 {
		lines = append(lines, c.genVars("var", c.Vars)...)
		lines = append(lines, "")
	}
	if len(c.Consts) > 0 {
		lines = append(lines, c.genVars("const", c.Consts)...)
		lines = append(lines, "")
	}
	if len(c.Structs) > 0 {
		lines = append(lines, c.genStructs()...)
		lines = append(lines, "")
	}
	lines = append(lines, c.Contents...)
	for i := range lines {
		lines[i] = strings.TrimRight(lines[i], " ")
	}

	data := []byte(strings.Join(lines, "\n"))

	return ioutil.WriteFile(path, data, 0644)
}

func (c *Coder) genHeader() []string {
	return []string{
		codePrefix[0],
		fmt.Sprintf(codePrefix[1], build.VERSION),
		fmt.Sprintf(codePrefix[2], c.Source),
	}
}

func (c *Coder) genPkg() string {
	return fmt.Sprintf("package %s", c.Pkg)
}

func (c *Coder) genImport() []string {
	sort.Slice(c.Imports, func(i, j int) bool {
		return c.Imports[i].Name < c.Imports[j].Name
	})
	lines := make([]string, 0, 2+len(c.Imports))
	lines = append(lines, "import (")
	for _, imp := range c.Imports {
		lines = append(lines, fmt.Sprintf(
			"\t%s %s", imp.Name, Quote(imp.Path)))
	}
	lines = append(lines, ")")
	return lines
}

func (c *Coder) genVars(def string, vs []Var) []string {
	lines := make([]string, 0, 2+len(c.Vars))
	lines = append(lines, fmt.Sprintf("%s (", def))
	align := 0
	for _, v := range vs {
		if len(v.Name) > align {
			align = len(v.Name)
		}
	}
	for _, v := range vs {
		lines = append(lines, fmt.Sprintf(
			"\t%s = %s", StrAlign(v.Name, align), v.Value))
	}
	lines = append(lines, ")")
	return lines
}

func (c *Coder) genStructs() []string {
	lines := make([]string, 0)
	for _, s := range c.Structs {
		comment := fmt.Sprintf("// %s %s",
			s.Name, s.Comment)
		def := fmt.Sprintf("type %s struct {", s.Name)
		lines = append(lines, comment)
		lines = append(lines, def)
		for _, f := range s.Fields {
			fcomment := fmt.Sprintf("\t// %s %s",
				f.Name, f.Comment)
			var fdef string
			if len(f.Tags) > 0 {
				tags := make([]string, len(f.Tags))
				for i, t := range f.Tags {
					tags[i] = fmt.Sprintf(`%s:"%s"`,

						t.Name, t.Value)
				}
				tagDef := strings.Join(tags, " ")
				fdef = fmt.Sprintf("\t%s %s `%s`",
					f.Name, f.Type, tagDef)
			} else {
				fdef = fmt.Sprintf("\t%s %s",
					f.Name, f.Type)
			}
			lines = append(lines, fcomment)
			lines = append(lines, fdef)
		}
		lines = append(lines, "}")
		lines = append(lines, "")
	}
	return lines
}

func comb(vs ...interface{}) string {
	strs := make([]string, len(vs))
	for i, v := range vs {
		strs[i] = fmt.Sprint(v)
	}
	return strings.Join(strs, "")
}

// Quote the string in double quotes
func Quote(ss ...string) string {
	s := strings.Join(ss, "")
	return fmt.Sprintf(`"%s"`, s)
}

// IsSimpleType determines whether the go type is a basic type.
func IsSimpleType(t string) bool {
	switch {
	case strings.HasPrefix(t, "int"):
		return true
	case strings.HasPrefix(t, "uint"):
		return true

	case t == "string":
		return true

	case t == "bool":
		return true

	case strings.HasPrefix(t, "float"):
		return true

	}

	return false
}

// GoName converts an underscore name into a camel case
// name with an initial capital letter.
func GoName(name string) string {
	if name == "" {
		return ""
	}
	parts := strings.Split(name, "_")
	for i := range parts {
		parts[i] = Export(parts[i])
	}

	return strings.Join(parts, "")
}

// Export capitalizes the first letter of the name.
func Export(s string) string {
	if len(s) == 0 {
		return ""
	}
	if len(s) == 1 {
		return string(unicode.ToLower(rune(s[0])))
	}
	return string(unicode.ToUpper(rune(s[0]))) + s[1:]
}

// Unexport lowercases the first letter of the name.
func Unexport(s string) string {
	if len(s) == 0 {
		return ""
	}
	if len(s) == 1 {
		return string(unicode.ToLower(rune(s[0])))
	}
	return string(unicode.ToLower(rune(s[0]))) + s[1:]
}

// StrAlign returns the string with a fixed length left aligned.
func StrAlign(s string, fix int) string {
	format := "%-" + strconv.Itoa(fix) + "s"
	return fmt.Sprintf(format, s)
}
